---
description: 자연어 기능 설명으로부터 기능 명세서를 생성하거나 업데이트합니다.
---

## 사용자 입력

```text
$ARGUMENTS
```

진행하기 전에 사용자 입력을 **반드시** 고려해야 합니다 (비어있지 않은 경우).

## 개요

사용자가 `/speckit.specify` 뒤에 입력한 텍스트가 기능 설명입니다. 아래에 `$ARGUMENTS`가 문자 그대로 표시되더라도 이 대화에서 항상 사용 가능하다고 가정하세요. 사용자가 빈 명령어를 제공한 경우에만 다시 요청하세요.

해당 기능 설명을 바탕으로 다음을 수행하세요:

1. **브랜치용 간결한 짧은 이름 생성** (2-4 단어):
   - 기능 설명을 분석하고 가장 의미 있는 키워드를 추출
   - 기능의 본질을 담은 2-4 단어의 짧은 이름 생성
   - 가능하면 동작-명사 형식 사용 (예: "add-user-auth", "fix-payment-bug")
   - 기술 용어와 약어 유지 (OAuth2, API, JWT 등)
   - 기능을 한눈에 이해할 수 있도록 간결하면서도 충분히 설명적으로 유지
   - 예시:
     - "사용자 인증을 추가하고 싶습니다" → "user-auth"
     - "API에 OAuth2 통합 구현" → "oauth2-api-integration"
     - "분석용 대시보드 생성" → "analytics-dashboard"
     - "결제 처리 타임아웃 버그 수정" → "fix-payment-timeout"

2. **새 브랜치 생성 전 기존 브랜치 확인**:

   a. 먼저, 최신 정보를 확인하기 위해 모든 원격 브랜치를 가져옵니다:
      ```bash
      git fetch --all --prune
      ```

   b. 짧은 이름에 대해 모든 소스에서 가장 높은 기능 번호 찾기:
      - 원격 브랜치: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 로컬 브랜치: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - Specs 디렉토리: `specs/[0-9]+-<short-name>` 패턴과 일치하는 디렉토리 확인

   c. 다음 사용 가능한 번호 결정:
      - 세 가지 소스 모두에서 모든 번호 추출
      - 가장 높은 번호 N 찾기
      - 새 브랜치 번호로 N+1 사용

   d. 계산된 번호와 짧은 이름으로 `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"` 스크립트 실행:
      - 기능 설명과 함께 `--number N+1`과 `--short-name "your-short-name"` 전달
      - Bash 예시: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 예시: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **중요**:
   - 가장 높은 번호를 찾기 위해 세 가지 소스(원격 브랜치, 로컬 브랜치, specs 디렉토리) 모두 확인
   - 정확한 짧은 이름 패턴과 일치하는 브랜치/디렉토리만 매칭
   - 이 짧은 이름으로 기존 브랜치/디렉토리가 없으면 번호 1부터 시작
   - 기능당 이 스크립트는 한 번만 실행해야 함
   - JSON은 터미널 출력으로 제공됨 - 항상 실제 찾고 있는 콘텐츠를 얻기 위해 참조
   - JSON 출력에는 BRANCH_NAME과 SPEC_FILE 경로가 포함됨
   - "I'm Groot"와 같이 인수에 작은따옴표가 있는 경우, 이스케이프 구문 사용: 예: 'I'\''m Groot' (또는 가능하면 큰따옴표 사용: "I'm Groot")

3. 필수 섹션을 이해하기 위해 `.specify/templates/spec-template.md`를 로드합니다.

4. 다음 실행 흐름을 따르세요:

    1. 입력에서 사용자 설명 파싱
       비어있으면: ERROR "기능 설명이 제공되지 않았습니다"
    2. 설명에서 핵심 개념 추출
       식별: 행위자, 동작, 데이터, 제약조건
    3. 불명확한 측면에 대해:
       - 컨텍스트와 업계 표준을 기반으로 합리적인 추측 수행
       - 다음 경우에만 [명확화 필요: 구체적 질문]으로 표시:
         - 선택이 기능 범위나 사용자 경험에 상당한 영향을 미치는 경우
         - 다른 의미를 가진 여러 합리적인 해석이 존재하는 경우
         - 합리적인 기본값이 없는 경우
       - **제한: 최대 3개의 [명확화 필요] 마커**
       - 영향도별 명확화 우선순위: 범위 > 보안/개인정보 > 사용자 경험 > 기술 세부사항
    4. 사용자 시나리오 및 테스트 섹션 작성
       명확한 사용자 흐름이 없으면: ERROR "사용자 시나리오를 결정할 수 없습니다"
    5. 기능 요구사항 생성
       각 요구사항은 테스트 가능해야 함
       명시되지 않은 세부사항에는 합리적인 기본값 사용 (가정 섹션에 문서화)
    6. 성공 기준 정의
       측정 가능하고 기술 중립적인 결과 생성
       정량적 지표(시간, 성능, 볼륨)와 정성적 측정(사용자 만족도, 작업 완료율) 모두 포함
       각 기준은 구현 세부사항 없이 검증 가능해야 함
    7. 핵심 엔티티 식별 (데이터 관련 시)
    8. 반환: SUCCESS (명세서 계획 준비 완료)

5. 템플릿 구조를 사용하여 SPEC_FILE에 명세서 작성, 섹션 순서와 제목을 유지하면서 플레이스홀더를 기능 설명(인수)에서 파생된 구체적인 세부사항으로 교체합니다.

6. **명세서 품질 검증**: 초기 명세서 작성 후, 품질 기준에 대해 검증합니다:

   a. **명세서 품질 체크리스트 생성**: 다음 검증 항목들을 포함하여 `FEATURE_DIR/checklists/requirements.md`에 체크리스트 파일 생성:

      ```markdown
      # 명세서 품질 체크리스트: [기능 이름]

      **목적**: 계획 단계로 진행하기 전에 명세서 완성도와 품질 검증
      **생성일**: [날짜]
      **기능**: [spec.md 링크]

      ## 콘텐츠 품질

      - [ ] 구현 세부사항 없음 (언어, 프레임워크, API)
      - [ ] 사용자 가치와 비즈니스 요구에 집중
      - [ ] 비기술 이해관계자를 위해 작성됨
      - [ ] 모든 필수 섹션 완료됨

      ## 요구사항 완성도

      - [ ] [명확화 필요] 마커가 남아있지 않음
      - [ ] 요구사항이 테스트 가능하고 명확함
      - [ ] 성공 기준이 측정 가능함
      - [ ] 성공 기준이 기술 중립적임 (구현 세부사항 없음)
      - [ ] 모든 수락 시나리오가 정의됨
      - [ ] 엣지 케이스가 식별됨
      - [ ] 범위가 명확하게 제한됨
      - [ ] 의존성과 가정이 식별됨

      ## 기능 준비 상태

      - [ ] 모든 기능 요구사항에 명확한 수락 기준이 있음
      - [ ] 사용자 시나리오가 주요 흐름을 다룸
      - [ ] 기능이 성공 기준에 정의된 측정 가능한 결과를 충족함
      - [ ] 명세서에 구현 세부사항이 누출되지 않음

      ## 비고

      - 미완료로 표시된 항목은 `/speckit.clarify` 또는 `/speckit.plan` 전에 명세서 업데이트 필요
      ```

   b. **검증 확인 실행**: 각 체크리스트 항목에 대해 명세서 검토:
      - 각 항목에 대해 통과/실패 여부 결정
      - 발견된 구체적인 문제 문서화 (관련 명세서 섹션 인용)

   c. **검증 결과 처리**:

      - **모든 항목 통과 시**: 체크리스트 완료로 표시하고 6단계로 진행

      - **항목 실패 시 ([명확화 필요] 제외)**:
        1. 실패한 항목과 구체적인 문제 나열
        2. 각 문제를 해결하기 위해 명세서 업데이트
        3. 모든 항목이 통과할 때까지 검증 재실행 (최대 3회 반복)
        4. 3회 반복 후에도 여전히 실패하면, 체크리스트 비고에 남은 문제 문서화하고 사용자에게 경고

      - **[명확화 필요] 마커가 남아있는 경우**:
        1. 명세서에서 모든 [명확화 필요: ...] 마커 추출
        2. **제한 확인**: 3개 이상의 마커가 있으면, 가장 중요한 3개만 유지 (범위/보안/UX 영향도 기준)하고 나머지는 합리적인 추측으로 처리
        3. 명확화가 필요한 각 항목에 대해 (최대 3개), 다음 형식으로 사용자에게 옵션 제시:

           ```markdown
           ## 질문 [N]: [주제]

           **컨텍스트**: [관련 명세서 섹션 인용]

           **알아야 할 것**: [명확화 필요 마커의 구체적 질문]

           **제안 답변**:

           | 옵션 | 답변 | 의미 |
           |------|------|------|
           | A    | [첫 번째 제안 답변] | [이것이 기능에 미치는 의미] |
           | B    | [두 번째 제안 답변] | [이것이 기능에 미치는 의미] |
           | C    | [세 번째 제안 답변] | [이것이 기능에 미치는 의미] |
           | 직접 입력 | 자신만의 답변 제공 | [사용자 정의 입력 방법 설명] |

           **선택**: _[사용자 응답 대기]_
           ```

        4. **중요 - 테이블 포맷팅**: 마크다운 테이블이 올바르게 포맷되었는지 확인:
           - 파이프가 정렬된 일관된 간격 사용
           - 각 셀에 콘텐츠 주위에 공백이 있어야 함: `| Content |` (아님 `|Content|`)
           - 헤더 구분자는 최소 3개의 대시가 있어야 함: `|--------|`
           - 테이블이 마크다운 미리보기에서 올바르게 렌더링되는지 테스트
        5. 질문에 순차적으로 번호 매기기 (Q1, Q2, Q3 - 총 최대 3개)
        6. 응답을 기다리기 전에 모든 질문을 함께 제시
        7. 사용자가 모든 질문에 대한 선택으로 응답할 때까지 대기 (예: "Q1: A, Q2: 직접 입력 - [세부사항], Q3: B")
        8. 각 [명확화 필요] 마커를 사용자가 선택하거나 제공한 답변으로 교체하여 명세서 업데이트
        9. 모든 명확화가 해결된 후 검증 재실행

   d. **체크리스트 업데이트**: 각 검증 반복 후, 현재 통과/실패 상태로 체크리스트 파일 업데이트

7. 브랜치 이름, 명세서 파일 경로, 체크리스트 결과, 다음 단계(`/speckit.clarify` 또는 `/speckit.plan`) 준비 상태와 함께 완료 보고.

**참고:** 스크립트는 작성 전에 새 브랜치를 생성하고 체크아웃하며 명세서 파일을 초기화합니다.

## 일반 가이드라인

## 빠른 가이드라인

- 사용자가 **무엇을** 필요로 하고 **왜** 필요한지에 집중.
- **어떻게** 구현할지는 피함 (기술 스택, API, 코드 구조 없음).
- 개발자가 아닌 비즈니스 이해관계자를 위해 작성.
- 명세서에 포함된 체크리스트는 생성하지 않음. 그것은 별도의 명령어로 처리.

### 섹션 요구사항

- **필수 섹션**: 모든 기능에 대해 반드시 완료해야 함
- **선택 섹션**: 기능과 관련된 경우에만 포함
- 섹션이 적용되지 않으면 완전히 제거 ("N/A"로 남기지 않음)

### AI 생성용

사용자 프롬프트에서 이 명세서를 생성할 때:

1. **합리적인 추측**: 컨텍스트, 업계 표준, 일반적인 패턴을 사용하여 공백 채우기
2. **가정 문서화**: 가정 섹션에 합리적인 기본값 기록
3. **명확화 제한**: 최대 3개의 [명확화 필요] 마커 - 다음과 같은 중요한 결정에만 사용:
   - 기능 범위나 사용자 경험에 상당한 영향을 미치는 경우
   - 다른 의미를 가진 여러 합리적인 해석이 존재하는 경우
   - 합리적인 기본값이 없는 경우
4. **명확화 우선순위**: 범위 > 보안/개인정보 > 사용자 경험 > 기술 세부사항
5. **테스터처럼 생각**: 모든 모호한 요구사항은 "테스트 가능하고 명확함" 체크리스트 항목에서 실패해야 함
6. **명확화가 필요한 일반적인 영역** (합리적인 기본값이 없는 경우에만):
   - 기능 범위 및 경계 (특정 사용 사례 포함/제외)
   - 사용자 유형 및 권한 (여러 상충되는 해석이 가능한 경우)
   - 보안/규정 준수 요구사항 (법적/재정적으로 중요한 경우)

**합리적인 기본값 예시** (이것들에 대해서는 묻지 않음):

- 데이터 보존: 해당 도메인의 업계 표준 관행
- 성능 목표: 특별히 명시되지 않으면 표준 웹/모바일 앱 기대치
- 오류 처리: 적절한 폴백과 함께 사용자 친화적인 메시지
- 인증 방법: 웹 앱의 경우 표준 세션 기반 또는 OAuth2
- 통합 패턴: 특별히 명시되지 않으면 RESTful API

### 성공 기준 가이드라인

성공 기준은 다음이어야 합니다:

1. **측정 가능**: 구체적인 지표 포함 (시간, 백분율, 개수, 비율)
2. **기술 중립적**: 프레임워크, 언어, 데이터베이스, 도구 언급 없음
3. **사용자 중심**: 시스템 내부가 아닌 사용자/비즈니스 관점에서 결과 설명
4. **검증 가능**: 구현 세부사항을 모르고도 테스트/검증 가능

**좋은 예시**:

- "사용자는 3분 이내에 결제를 완료할 수 있음"
- "시스템은 10,000명의 동시 사용자를 지원함"
- "검색의 95%가 1초 이내에 결과를 반환함"
- "작업 완료율이 40% 향상됨"

**나쁜 예시** (구현 중심):

- "API 응답 시간이 200ms 미만" (너무 기술적, "사용자가 즉시 결과를 볼 수 있음" 사용)
- "데이터베이스가 1000 TPS를 처리할 수 있음" (구현 세부사항, 사용자 대면 지표 사용)
- "React 컴포넌트가 효율적으로 렌더링됨" (프레임워크별)
- "Redis 캐시 히트율 80% 이상" (기술별)
