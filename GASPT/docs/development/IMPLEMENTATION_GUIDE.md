# ğŸ› ï¸ GASPT ìˆ˜ë™ êµ¬í˜„ ê°€ì´ë“œ

**í”„ë¡œì íŠ¸ëª…**: GASPT (Generic Ability System + FSM Platform Game)
**ì‘ì„±ì¼**: 2025-11-19
**ëª©ì **: ì„œë²„ ì˜¤ë¥˜ ì‹œ ìˆ˜ë™ìœ¼ë¡œ ì‘ì—…í•  ìˆ˜ ìˆëŠ” ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œ

---

## ğŸ“‹ ëª©ì°¨

1. [ê°€ì´ë“œ ì‚¬ìš© ë°©ë²•](#ê°€ì´ë“œ-ì‚¬ìš©-ë°©ë²•)
2. [Phase E-1: ì ˆì°¨ì  ë ˆë²¨ ìƒì„± ì‹œìŠ¤í…œ](#phase-e-1-ì ˆì°¨ì -ë ˆë²¨-ìƒì„±-ì‹œìŠ¤í…œ)
3. [Phase E-2: ìŠ¤ì»¬ êµì²´ ì‹œìŠ¤í…œ](#phase-e-2-ìŠ¤ì»¬-êµì²´-ì‹œìŠ¤í…œ)
4. [Phase E-3: ë©”íƒ€ ì§„í–‰ ì‹œìŠ¤í…œ](#phase-e-3-ë©”íƒ€-ì§„í–‰-ì‹œìŠ¤í…œ)
5. [ì‹œìŠ¤í…œë³„ êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸](#ì‹œìŠ¤í…œë³„-êµ¬í˜„-ì²´í¬ë¦¬ìŠ¤íŠ¸)
6. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œ](#íŠ¸ëŸ¬ë¸”ìŠˆíŒ…-ê°€ì´ë“œ)
7. [ì½”ë“œ ìŠ¤ë‹ˆí« ë¼ì´ë¸ŒëŸ¬ë¦¬](#ì½”ë“œ-ìŠ¤ë‹ˆí«-ë¼ì´ë¸ŒëŸ¬ë¦¬)

---

## ğŸ“– ê°€ì´ë“œ ì‚¬ìš© ë°©ë²•

### ì„œë²„ ì˜¤ë¥˜ ë°œìƒ ì‹œ ë³µêµ¬ ì ˆì°¨

1. **í˜„ì¬ ìƒíƒœ íŒŒì•…** (5ë¶„)
   ```bash
   # ë§ˆì§€ë§‰ ì»¤ë°‹ í™•ì¸
   git log -1

   # í˜„ì¬ ë³€ê²½ ì‚¬í•­ í™•ì¸
   git status

   # í˜„ì¬ Phase í™•ì¸
   # PROJECT_MASTER_ROADMAP.md ì°¸ì¡°
   ```

2. **ë¬¸ì„œ í™•ì¸** (10ë¶„)
   - `PROJECT_MASTER_ROADMAP.md`: ì „ì²´ ë¡œë“œë§µ ë° í˜„ì¬ Phase í™•ì¸
   - `WORK_HISTORY.md`: ì™„ë£Œëœ ì‘ì—… í™•ì¸
   - `IMPLEMENTATION_GUIDE.md` (ë³¸ ë¬¸ì„œ): ë‹¤ìŒ ì‘ì—… êµ¬í˜„ ë°©ë²• í™•ì¸

3. **ë‹¨ê³„ë³„ êµ¬í˜„** (ì‘ì—… ì‹œê°„ ì†Œìš”)
   - ë³¸ ë¬¸ì„œì˜ ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ë”°ë¼ ë‹¨ê³„ë³„ë¡œ êµ¬í˜„
   - ê° ë‹¨ê³„ ì™„ë£Œ ì‹œ ì»¤ë°‹ ìƒì„±
   - ì½”ë“œ ìŠ¤ë‹ˆí« ì°¸ì¡°í•˜ì—¬ í•µì‹¬ ë¡œì§ ì‘ì„±

4. **í…ŒìŠ¤íŠ¸ ë° ê²€ì¦** (10-20ë¶„)
   - Unityì—ì„œ í”Œë ˆì´ ëª¨ë“œ ì‹¤í–‰
   - ê¸°ëŠ¥ ë™ì‘ í™•ì¸
   - ë²„ê·¸ ë°œê²¬ ì‹œ ì¦‰ì‹œ ìˆ˜ì •

---

## ğŸ® Phase E-1: ì ˆì°¨ì  ë ˆë²¨ ìƒì„± ì‹œìŠ¤í…œ

**ì˜ˆìƒ ê¸°ê°„**: 2-3ì£¼
**í˜„ì¬ ìƒíƒœ**: ë¯¸ì°©ìˆ˜ (0%)
**ì„ í–‰ ìš”êµ¬ì‚¬í•­**: Phase C-3 (ë˜ì „ ì§„í–‰ ì‹œìŠ¤í…œ) ì™„ë£Œ

---

### Step 1: RoomGenerator êµ¬í˜„ (1ì£¼)

#### 1.1 RoomType Enum ì¶”ê°€

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/Core/Enums/RoomType.cs`

**ì‘ì—… ë‚´ìš©**:
```csharp
namespace Core.Enums
{
    /// <summary>
    /// ë°© íƒ€ì…
    /// </summary>
    public enum RoomType
    {
        Start,        // ì‹œì‘ ë°©
        Normal,       // ì¼ë°˜ ì „íˆ¬ ë°©
        Elite,        // ì—˜ë¦¬íŠ¸ ì „íˆ¬ ë°©
        Boss,         // ë³´ìŠ¤ ë°©
        Treasure,     // ë³´ë¬¼ ë°©
        Shop,         // ìƒì  ë°©
        Rest,         // íœ´ì‹ ë°©
        Event         // ì´ë²¤íŠ¸ ë°©
    }
}
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
- [ ] RoomType.cs íŒŒì¼ ìƒì„±
- [ ] 8ê°€ì§€ RoomType ì •ì˜
- [ ] XML ì£¼ì„ ì¶”ê°€
- [ ] Core.Enums ë„¤ì„ìŠ¤í˜ì´ìŠ¤ í™•ì¸

---

#### 1.2 RoomData í™•ì¥

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/Gameplay/Level/Room/RoomData.cs` (ê¸°ì¡´ íŒŒì¼ ìˆ˜ì •)

**ì¶”ê°€ í•„ë“œ**:
```csharp
using Core.Enums;
using UnityEngine;

[CreateAssetMenu(fileName = "RoomData", menuName = "GASPT/Level/Room Data")]
public class RoomData : ScriptableObject
{
    // ê¸°ì¡´ í•„ë“œ
    // ...

    // ìƒˆë¡œ ì¶”ê°€í•  í•„ë“œ
    [Header("Room Type")]
    [Tooltip("ë°© íƒ€ì…")]
    public RoomType roomType = RoomType.Normal;

    [Header("Room Properties")]
    [Tooltip("ë°© ë„ˆë¹„ (íƒ€ì¼ ë‹¨ìœ„)")]
    [Range(10, 50)]
    public int roomWidth = 20;

    [Tooltip("ë°© ë†’ì´ (íƒ€ì¼ ë‹¨ìœ„)")]
    [Range(10, 30)]
    public int roomHeight = 15;

    [Tooltip("í”Œë«í¼ ê°œìˆ˜ (ëœë¤ ë°°ì¹˜)")]
    [Range(0, 10)]
    public int platformCount = 3;

    [Tooltip("ì¥ì• ë¬¼ ê°œìˆ˜ (ê°€ì‹œ, í•¨ì •)")]
    [Range(0, 5)]
    public int obstacleCount = 1;

    [Header("Rewards")]
    [Tooltip("í´ë¦¬ì–´ ì‹œ ê³¨ë“œ ë³´ìƒ")]
    public int goldReward = 50;

    [Tooltip("í´ë¦¬ì–´ ì‹œ ê²½í—˜ì¹˜ ë³´ìƒ")]
    public int expReward = 100;
}
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
- [ ] RoomType í•„ë“œ ì¶”ê°€
- [ ] ë°© í¬ê¸° í•„ë“œ ì¶”ê°€ (roomWidth, roomHeight)
- [ ] í”Œë«í¼/ì¥ì• ë¬¼ ê°œìˆ˜ í•„ë“œ ì¶”ê°€
- [ ] ë³´ìƒ í•„ë“œ ì¶”ê°€ (goldReward, expReward)
- [ ] Range ì†ì„± ì¶”ê°€í•˜ì—¬ Inspectorì—ì„œ ì¡°ì ˆ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •

---

#### 1.3 RoomGenerator í´ë˜ìŠ¤ ìƒì„±

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/Gameplay/Level/Room/RoomGenerator.cs`

**í•µì‹¬ ë¡œì§**:
```csharp
using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections.Generic;

namespace GASPT.Level
{
    /// <summary>
    /// ë°© ìƒì„±ê¸°
    /// RoomDataë¥¼ ê¸°ë°˜ìœ¼ë¡œ Tilemap ìƒì„±
    /// </summary>
    public class RoomGenerator : MonoBehaviour
    {
        [Header("Tilemap References")]
        [SerializeField] private Tilemap groundTilemap;
        [SerializeField] private Tilemap platformTilemap;
        [SerializeField] private Tilemap obstacleTilemap;

        [Header("Tiles")]
        [SerializeField] private TileBase groundTile;
        [SerializeField] private TileBase platformTile;
        [SerializeField] private TileBase spikeTile;

        /// <summary>
        /// RoomDataë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë°© ìƒì„±
        /// </summary>
        public void GenerateRoom(RoomData roomData)
        {
            if (roomData == null)
            {
                Debug.LogError("[RoomGenerator] RoomDataê°€ nullì…ë‹ˆë‹¤.");
                return;
            }

            // ê¸°ì¡´ íƒ€ì¼ ì œê±°
            ClearRoom();

            // ë°”ë‹¥ ìƒì„±
            GenerateGround(roomData);

            // í”Œë«í¼ ìƒì„±
            GeneratePlatforms(roomData);

            // ì¥ì• ë¬¼ ìƒì„±
            GenerateObstacles(roomData);

            Debug.Log($"[RoomGenerator] ë°© ìƒì„± ì™„ë£Œ: {roomData.roomType}");
        }

        /// <summary>
        /// ê¸°ì¡´ íƒ€ì¼ ì œê±°
        /// </summary>
        private void ClearRoom()
        {
            if (groundTilemap != null) groundTilemap.ClearAllTiles();
            if (platformTilemap != null) platformTilemap.ClearAllTiles();
            if (obstacleTilemap != null) obstacleTilemap.ClearAllTiles();
        }

        /// <summary>
        /// ë°”ë‹¥ ìƒì„±
        /// </summary>
        private void GenerateGround(RoomData roomData)
        {
            if (groundTilemap == null || groundTile == null)
                return;

            // ë°”ë‹¥ í•œ ì¤„ ìƒì„±
            for (int x = 0; x < roomData.roomWidth; x++)
            {
                Vector3Int tilePos = new Vector3Int(x, 0, 0);
                groundTilemap.SetTile(tilePos, groundTile);
            }
        }

        /// <summary>
        /// í”Œë«í¼ ëœë¤ ìƒì„±
        /// </summary>
        private void GeneratePlatforms(RoomData roomData)
        {
            if (platformTilemap == null || platformTile == null)
                return;

            for (int i = 0; i < roomData.platformCount; i++)
            {
                // ëœë¤ ìœ„ì¹˜ ë° í¬ê¸°
                int platformWidth = Random.Range(3, 8);
                int platformX = Random.Range(2, roomData.roomWidth - platformWidth - 2);
                int platformY = Random.Range(3, roomData.roomHeight - 2);

                // í”Œë«í¼ ìƒì„±
                for (int x = 0; x < platformWidth; x++)
                {
                    Vector3Int tilePos = new Vector3Int(platformX + x, platformY, 0);
                    platformTilemap.SetTile(tilePos, platformTile);
                }
            }
        }

        /// <summary>
        /// ì¥ì• ë¬¼ ëœë¤ ìƒì„±
        /// </summary>
        private void GenerateObstacles(RoomData roomData)
        {
            if (obstacleTilemap == null || spikeTile == null)
                return;

            for (int i = 0; i < roomData.obstacleCount; i++)
            {
                // ëœë¤ ìœ„ì¹˜ (ë°”ë‹¥ ìœ„)
                int obstacleX = Random.Range(2, roomData.roomWidth - 2);
                int obstacleY = 1; // ë°”ë‹¥ ë°”ë¡œ ìœ„

                Vector3Int tilePos = new Vector3Int(obstacleX, obstacleY, 0);
                obstacleTilemap.SetTile(tilePos, spikeTile);
            }
        }
    }
}
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
- [ ] RoomGenerator.cs íŒŒì¼ ìƒì„±
- [ ] Tilemap ì°¸ì¡° í•„ë“œ ì¶”ê°€
- [ ] Tile ì°¸ì¡° í•„ë“œ ì¶”ê°€
- [ ] GenerateRoom() ë©”ì„œë“œ êµ¬í˜„
- [ ] ClearRoom() ë©”ì„œë“œ êµ¬í˜„
- [ ] GenerateGround() ë©”ì„œë“œ êµ¬í˜„
- [ ] GeneratePlatforms() ë©”ì„œë“œ êµ¬í˜„
- [ ] GenerateObstacles() ë©”ì„œë“œ êµ¬í˜„
- [ ] XML ì£¼ì„ ì¶”ê°€

---

### Step 2: DungeonGenerator êµ¬í˜„ (1ì£¼)

#### 2.1 DungeonLayout ë°ì´í„° êµ¬ì¡°

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/Gameplay/Level/Dungeon/DungeonLayout.cs`

**í•µì‹¬ ë¡œì§**:
```csharp
using UnityEngine;
using System.Collections.Generic;
using Core.Enums;

namespace GASPT.Level
{
    /// <summary>
    /// ë˜ì „ ë ˆì´ì•„ì›ƒ
    /// ë°©ë“¤ì˜ ì—°ê²° êµ¬ì¡°ë¥¼ ë‚˜íƒ€ëƒ„
    /// </summary>
    [System.Serializable]
    public class DungeonNode
    {
        public int nodeId;
        public RoomType roomType;
        public Vector2Int gridPosition;
        public List<int> connectedNodes = new List<int>();

        public DungeonNode(int id, RoomType type, Vector2Int position)
        {
            nodeId = id;
            roomType = type;
            gridPosition = position;
        }
    }

    /// <summary>
    /// ë˜ì „ ë ˆì´ì•„ì›ƒ
    /// </summary>
    public class DungeonLayout
    {
        public List<DungeonNode> nodes = new List<DungeonNode>();
        public int startNodeId;
        public int bossNodeId;

        /// <summary>
        /// ë…¸ë“œ ì¶”ê°€
        /// </summary>
        public void AddNode(DungeonNode node)
        {
            nodes.Add(node);
        }

        /// <summary>
        /// ë…¸ë“œ ì—°ê²°
        /// </summary>
        public void ConnectNodes(int nodeId1, int nodeId2)
        {
            DungeonNode node1 = nodes.Find(n => n.nodeId == nodeId1);
            DungeonNode node2 = nodes.Find(n => n.nodeId == nodeId2);

            if (node1 != null && node2 != null)
            {
                if (!node1.connectedNodes.Contains(nodeId2))
                    node1.connectedNodes.Add(nodeId2);

                if (!node2.connectedNodes.Contains(nodeId1))
                    node2.connectedNodes.Add(nodeId1);
            }
        }

        /// <summary>
        /// IDë¡œ ë…¸ë“œ ì°¾ê¸°
        /// </summary>
        public DungeonNode GetNode(int nodeId)
        {
            return nodes.Find(n => n.nodeId == nodeId);
        }
    }
}
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
- [ ] DungeonLayout.cs íŒŒì¼ ìƒì„±
- [ ] DungeonNode í´ë˜ìŠ¤ ì •ì˜
- [ ] DungeonLayout í´ë˜ìŠ¤ ì •ì˜
- [ ] AddNode() ë©”ì„œë“œ êµ¬í˜„
- [ ] ConnectNodes() ë©”ì„œë“œ êµ¬í˜„
- [ ] GetNode() ë©”ì„œë“œ êµ¬í˜„

---

#### 2.2 DungeonGenerator í´ë˜ìŠ¤

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/Gameplay/Level/Dungeon/DungeonGenerator.cs`

**í•µì‹¬ ë¡œì§**:
```csharp
using UnityEngine;
using System.Collections.Generic;
using Core.Enums;

namespace GASPT.Level
{
    /// <summary>
    /// ë˜ì „ ìƒì„±ê¸°
    /// Graph ê¸°ë°˜ìœ¼ë¡œ ë˜ì „ ë ˆì´ì•„ì›ƒ ìƒì„±
    /// </summary>
    public class DungeonGenerator : MonoBehaviour
    {
        [Header("Dungeon Settings")]
        [Tooltip("ë˜ì „ ì¸µìˆ˜")]
        [Range(1, 10)]
        public int floorCount = 3;

        [Tooltip("ì¸µë‹¹ ë°© ê°œìˆ˜ (ìµœì†Œ)")]
        [Range(3, 10)]
        public int minRoomsPerFloor = 5;

        [Tooltip("ì¸µë‹¹ ë°© ê°œìˆ˜ (ìµœëŒ€)")]
        [Range(5, 15)]
        public int maxRoomsPerFloor = 10;

        /// <summary>
        /// ë˜ì „ ë ˆì´ì•„ì›ƒ ìƒì„±
        /// </summary>
        public DungeonLayout GenerateDungeon()
        {
            DungeonLayout layout = new DungeonLayout();

            int roomsPerFloor = Random.Range(minRoomsPerFloor, maxRoomsPerFloor + 1);
            int totalRooms = roomsPerFloor * floorCount;

            // ë…¸ë“œ ìƒì„±
            for (int i = 0; i < totalRooms; i++)
            {
                RoomType roomType = DetermineRoomType(i, totalRooms);
                Vector2Int gridPos = new Vector2Int(i % roomsPerFloor, i / roomsPerFloor);

                DungeonNode node = new DungeonNode(i, roomType, gridPos);
                layout.AddNode(node);

                // ì‹œì‘/ë³´ìŠ¤ ë°© ì„¤ì •
                if (i == 0) layout.startNodeId = i;
                if (i == totalRooms - 1) layout.bossNodeId = i;
            }

            // ë…¸ë“œ ì—°ê²° (ê°„ë‹¨í•œ ì„ í˜• ê²½ë¡œ)
            for (int i = 0; i < totalRooms - 1; i++)
            {
                layout.ConnectNodes(i, i + 1);

                // ëœë¤ ì¶”ê°€ ì—°ê²° (ì„ íƒì  ê²½ë¡œ)
                if (Random.value > 0.7f && i + 2 < totalRooms)
                {
                    layout.ConnectNodes(i, i + 2);
                }
            }

            Debug.Log($"[DungeonGenerator] ë˜ì „ ìƒì„± ì™„ë£Œ: {totalRooms}ê°œ ë°©");
            return layout;
        }

        /// <summary>
        /// ë°© íƒ€ì… ê²°ì •
        /// </summary>
        private RoomType DetermineRoomType(int index, int totalRooms)
        {
            if (index == 0) return RoomType.Start;
            if (index == totalRooms - 1) return RoomType.Boss;

            // ëœë¤ ë°© íƒ€ì…
            float rand = Random.value;

            if (rand < 0.5f) return RoomType.Normal;
            if (rand < 0.7f) return RoomType.Elite;
            if (rand < 0.85f) return RoomType.Treasure;
            if (rand < 0.95f) return RoomType.Shop;
            return RoomType.Rest;
        }
    }
}
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
- [ ] DungeonGenerator.cs íŒŒì¼ ìƒì„±
- [ ] ë˜ì „ ì„¤ì • í•„ë“œ ì¶”ê°€
- [ ] GenerateDungeon() ë©”ì„œë“œ êµ¬í˜„
- [ ] DetermineRoomType() ë©”ì„œë“œ êµ¬í˜„
- [ ] ì‹œì‘ ë°© â†’ ë³´ìŠ¤ ë°© ê²½ë¡œ ë³´ì¥
- [ ] ì„ íƒì  ê²½ë¡œ ìƒì„± (ëœë¤ ì—°ê²°)

---

### Step 3: Minimap ì‹œìŠ¤í…œ (3-5ì¼)

#### 3.1 MinimapUI í´ë˜ìŠ¤

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/UI/MinimapUI.cs`

**í•µì‹¬ ë¡œì§**:
```csharp
using UnityEngine;
using UnityEngine.UI;
using GASPT.Level;
using System.Collections.Generic;

namespace GASPT.UI
{
    /// <summary>
    /// ë¯¸ë‹ˆë§µ UI
    /// ë˜ì „ ë ˆì´ì•„ì›ƒì„ ì‹œê°í™”
    /// </summary>
    public class MinimapUI : BaseUI
    {
        [Header("Minimap Settings")]
        [SerializeField] private RectTransform minimapContainer;
        [SerializeField] private GameObject roomIconPrefab;

        [Header("Room Icons")]
        [SerializeField] private Sprite startRoomIcon;
        [SerializeField] private Sprite normalRoomIcon;
        [SerializeField] private Sprite bossRoomIcon;
        [SerializeField] private Sprite currentRoomIcon;

        private Dictionary<int, GameObject> roomIcons = new Dictionary<int, GameObject>();
        private int currentRoomId = 0;

        /// <summary>
        /// ë˜ì „ ë ˆì´ì•„ì›ƒìœ¼ë¡œ ë¯¸ë‹ˆë§µ ìƒì„±
        /// </summary>
        public void GenerateMinimap(DungeonLayout layout)
        {
            // ê¸°ì¡´ ì•„ì´ì½˜ ì œê±°
            ClearMinimap();

            // ë°© ì•„ì´ì½˜ ìƒì„±
            foreach (var node in layout.nodes)
            {
                GameObject iconObj = Instantiate(roomIconPrefab, minimapContainer);
                Image iconImage = iconObj.GetComponent<Image>();

                // ë°© íƒ€ì…ì— ë”°ë¥¸ ì•„ì´ì½˜ ì„¤ì •
                if (node.nodeId == layout.startNodeId)
                    iconImage.sprite = startRoomIcon;
                else if (node.nodeId == layout.bossNodeId)
                    iconImage.sprite = bossRoomIcon;
                else
                    iconImage.sprite = normalRoomIcon;

                // ìœ„ì¹˜ ì„¤ì • (ê·¸ë¦¬ë“œ ê¸°ë°˜)
                RectTransform iconRect = iconObj.GetComponent<RectTransform>();
                iconRect.anchoredPosition = new Vector2(
                    node.gridPosition.x * 100f,
                    node.gridPosition.y * 100f
                );

                roomIcons[node.nodeId] = iconObj;
            }

            // ì‹œì‘ ë°©ì„ í˜„ì¬ ë°©ìœ¼ë¡œ ì„¤ì •
            UpdateCurrentRoom(layout.startNodeId);
        }

        /// <summary>
        /// í˜„ì¬ ë°© ì—…ë°ì´íŠ¸
        /// </summary>
        public void UpdateCurrentRoom(int roomId)
        {
            // ì´ì „ í˜„ì¬ ë°© ì•„ì´ì½˜ ë³µêµ¬
            if (roomIcons.ContainsKey(currentRoomId))
            {
                Image prevIcon = roomIcons[currentRoomId].GetComponent<Image>();
                // ì›ë˜ ì•„ì´ì½˜ìœ¼ë¡œ ë³µêµ¬ (ë¡œì§ ì¶”ê°€ í•„ìš”)
            }

            // ìƒˆ í˜„ì¬ ë°© í‘œì‹œ
            if (roomIcons.ContainsKey(roomId))
            {
                Image newIcon = roomIcons[roomId].GetComponent<Image>();
                newIcon.sprite = currentRoomIcon;
                currentRoomId = roomId;
            }
        }

        /// <summary>
        /// ë¯¸ë‹ˆë§µ ì´ˆê¸°í™”
        /// </summary>
        private void ClearMinimap()
        {
            foreach (var icon in roomIcons.Values)
            {
                Destroy(icon);
            }
            roomIcons.Clear();
        }
    }
}
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
- [ ] MinimapUI.cs íŒŒì¼ ìƒì„±
- [ ] BaseUI ìƒì†
- [ ] ë°© ì•„ì´ì½˜ í”„ë¦¬íŒ¹ ì°¸ì¡° ì¶”ê°€
- [ ] GenerateMinimap() ë©”ì„œë“œ êµ¬í˜„
- [ ] UpdateCurrentRoom() ë©”ì„œë“œ êµ¬í˜„
- [ ] ClearMinimap() ë©”ì„œë“œ êµ¬í˜„

---

## ğŸ¦´ Phase E-2: ìŠ¤ì»¬ êµì²´ ì‹œìŠ¤í…œ

**ì˜ˆìƒ ê¸°ê°„**: 3-4ì£¼
**í˜„ì¬ ìƒíƒœ**: ë¯¸ì°©ìˆ˜ (0%)
**ì„ í–‰ ìš”êµ¬ì‚¬í•­**: Phase A-1 (MageForm ì‹œìŠ¤í…œ) ì™„ë£Œ

---

### Step 1: SkullData ScriptableObject (1ì£¼)

#### 1.1 SkullData í´ë˜ìŠ¤

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/Data/SkullData.cs`

**í•µì‹¬ ë¡œì§**:
```csharp
using UnityEngine;
using GASPT.Stats;

namespace GASPT.Data
{
    /// <summary>
    /// ìŠ¤ì»¬ ë°ì´í„°
    /// ìŠ¤ì»¬ë³„ ìŠ¤íƒ¯, ìŠ¤í‚¬, ì• ë‹ˆë©”ì´ì…˜ ì •ì˜
    /// </summary>
    [CreateAssetMenu(fileName = "SkullData", menuName = "GASPT/Skull/Skull Data")]
    public class SkullData : ScriptableObject
    {
        [Header("Basic Info")]
        [Tooltip("ìŠ¤ì»¬ ì´ë¦„")]
        public string skullName;

        [Tooltip("ìŠ¤ì»¬ ì„¤ëª…")]
        [TextArea(3, 5)]
        public string description;

        [Tooltip("ìŠ¤ì»¬ ì•„ì´ì½˜")]
        public Sprite icon;

        [Header("Stats")]
        [Tooltip("ì²´ë ¥ ì¦ê°€ëŸ‰")]
        public int healthBonus = 0;

        [Tooltip("ê³µê²©ë ¥ ì¦ê°€ëŸ‰")]
        public int attackBonus = 0;

        [Tooltip("ë°©ì–´ë ¥ ì¦ê°€ëŸ‰")]
        public int defenseBonus = 0;

        [Tooltip("ì´ë™ ì†ë„ ë°°ìœ¨")]
        [Range(0.5f, 2f)]
        public float moveSpeedMultiplier = 1f;

        [Header("Abilities")]
        [Tooltip("ê¸°ë³¸ ê³µê²© (ì¢Œí´ë¦­)")]
        public string basicAttackAbilityName;

        [Tooltip("ìŠ¤í‚¬ 1 (Qí‚¤)")]
        public string skill1AbilityName;

        [Tooltip("ìŠ¤í‚¬ 2 (Eí‚¤)")]
        public string skill2AbilityName;

        [Tooltip("ê¶ê·¹ê¸° (Rí‚¤)")]
        public string ultimateAbilityName;

        [Header("Visuals")]
        [Tooltip("ìŠ¤í”„ë¼ì´íŠ¸ (Idle, Run, Attack ë“±)")]
        public RuntimeAnimatorController animatorController;

        [Tooltip("ê¸°ë³¸ ìŠ¤í”„ë¼ì´íŠ¸ (Idle)")]
        public Sprite idleSprite;
    }
}
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
- [ ] SkullData.cs íŒŒì¼ ìƒì„±
- [ ] ê¸°ë³¸ ì •ë³´ í•„ë“œ ì¶”ê°€
- [ ] ìŠ¤íƒ¯ í•„ë“œ ì¶”ê°€
- [ ] ì–´ë¹Œë¦¬í‹° í•„ë“œ ì¶”ê°€
- [ ] ë¹„ì£¼ì–¼ í•„ë“œ ì¶”ê°€
- [ ] CreateAssetMenu ì†ì„± ì¶”ê°€

---

### Step 2: SkullManager êµ¬í˜„ (1-2ì£¼)

#### 2.1 SkullManager í´ë˜ìŠ¤

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/Gameplay/Skull/SkullManager.cs`

**í•µì‹¬ ë¡œì§**:
```csharp
using UnityEngine;
using System.Collections.Generic;
using GASPT.Data;
using GASPT.Stats;

namespace GASPT.Skull
{
    /// <summary>
    /// ìŠ¤ì»¬ ë§¤ë‹ˆì €
    /// ìŠ¤ì»¬ êµì²´ ë° ê´€ë¦¬
    /// </summary>
    public class SkullManager : MonoBehaviour
    {
        [Header("Skull Settings")]
        [Tooltip("ì†Œìœ  ìŠ¤ì»¬ ëª©ë¡")]
        [SerializeField] private List<SkullData> ownedSkulls = new List<SkullData>();

        [Tooltip("ì‹œì‘ ìŠ¤ì»¬")]
        [SerializeField] private SkullData startingSkull;

        [Header("Transform Settings")]
        [Tooltip("ë³€ì‹  ì¿¨ë‹¤ìš´ (ì´ˆ)")]
        [SerializeField] private float transformCooldown = 1f;

        private SkullData currentSkull;
        private PlayerStats playerStats;
        private Animator playerAnimator;
        private SpriteRenderer playerRenderer;

        private float lastTransformTime = 0f;
        private int currentSkullIndex = 0;

        private void Start()
        {
            playerStats = GetComponent<PlayerStats>();
            playerAnimator = GetComponent<Animator>();
            playerRenderer = GetComponent<SpriteRenderer>();

            // ì‹œì‘ ìŠ¤ì»¬ ì¥ì°©
            if (startingSkull != null)
            {
                EquipSkull(startingSkull);
            }
        }

        private void Update()
        {
            // Qí‚¤ë¡œ ìŠ¤ì»¬ êµì²´
            if (Input.GetKeyDown(KeyCode.Q))
            {
                TransformToNextSkull();
            }
        }

        /// <summary>
        /// ë‹¤ìŒ ìŠ¤ì»¬ë¡œ ë³€ì‹ 
        /// </summary>
        public void TransformToNextSkull()
        {
            // ì¿¨ë‹¤ìš´ ì²´í¬
            if (Time.time - lastTransformTime < transformCooldown)
            {
                Debug.Log("[SkullManager] ë³€ì‹  ì¿¨ë‹¤ìš´ ì¤‘");
                return;
            }

            if (ownedSkulls.Count == 0)
            {
                Debug.LogWarning("[SkullManager] ì†Œìœ  ìŠ¤ì»¬ì´ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }

            // ë‹¤ìŒ ìŠ¤ì»¬ ì¸ë±ìŠ¤
            currentSkullIndex = (currentSkullIndex + 1) % ownedSkulls.Count;
            SkullData nextSkull = ownedSkulls[currentSkullIndex];

            // ìŠ¤ì»¬ ì¥ì°©
            EquipSkull(nextSkull);

            lastTransformTime = Time.time;
            Debug.Log($"[SkullManager] {nextSkull.skullName}(ìœ¼)ë¡œ ë³€ì‹ ");
        }

        /// <summary>
        /// ìŠ¤ì»¬ ì¥ì°©
        /// </summary>
        public void EquipSkull(SkullData skull)
        {
            if (skull == null)
                return;

            currentSkull = skull;

            // ìŠ¤íƒ¯ ì ìš©
            ApplySkullStats(skull);

            // ë¹„ì£¼ì–¼ ì ìš©
            ApplySkullVisuals(skull);

            // ì–´ë¹Œë¦¬í‹° ì ìš© (GAS ì—°ë™ í•„ìš”)
            ApplySkullAbilities(skull);
        }

        /// <summary>
        /// ìŠ¤ì»¬ ìŠ¤íƒ¯ ì ìš©
        /// </summary>
        private void ApplySkullStats(SkullData skull)
        {
            if (playerStats == null)
                return;

            // ê¸°ë³¸ ìŠ¤íƒ¯ì— ë³´ë„ˆìŠ¤ ì¶”ê°€
            // (playerStats.SetBonusHealth(skull.healthBonus) ë“± êµ¬í˜„ í•„ìš”)
        }

        /// <summary>
        /// ìŠ¤ì»¬ ë¹„ì£¼ì–¼ ì ìš©
        /// </summary>
        private void ApplySkullVisuals(SkullData skull)
        {
            // ì• ë‹ˆë©”ì´í„° ì»¨íŠ¸ë¡¤ëŸ¬ êµì²´
            if (playerAnimator != null && skull.animatorController != null)
            {
                playerAnimator.runtimeAnimatorController = skull.animatorController;
            }

            // ê¸°ë³¸ ìŠ¤í”„ë¼ì´íŠ¸ ì„¤ì •
            if (playerRenderer != null && skull.idleSprite != null)
            {
                playerRenderer.sprite = skull.idleSprite;
            }
        }

        /// <summary>
        /// ìŠ¤ì»¬ ì–´ë¹Œë¦¬í‹° ì ìš©
        /// </summary>
        private void ApplySkullAbilities(SkullData skull)
        {
            // GASì™€ ì—°ë™í•˜ì—¬ ì–´ë¹Œë¦¬í‹° êµì²´
            // (AbilitySystem.ReplaceAbility() ë“± êµ¬í˜„ í•„ìš”)
        }

        /// <summary>
        /// ìŠ¤ì»¬ ì¶”ê°€
        /// </summary>
        public void AddSkull(SkullData skull)
        {
            if (!ownedSkulls.Contains(skull))
            {
                ownedSkulls.Add(skull);
                Debug.Log($"[SkullManager] ìƒˆ ìŠ¤ì»¬ íšë“: {skull.skullName}");
            }
        }

        // Getters
        public SkullData CurrentSkull => currentSkull;
        public List<SkullData> OwnedSkulls => ownedSkulls;
    }
}
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
- [ ] SkullManager.cs íŒŒì¼ ìƒì„±
- [ ] ì†Œìœ  ìŠ¤ì»¬ ëª©ë¡ ê´€ë¦¬
- [ ] TransformToNextSkull() ë©”ì„œë“œ êµ¬í˜„
- [ ] EquipSkull() ë©”ì„œë“œ êµ¬í˜„
- [ ] ApplySkullStats() ë©”ì„œë“œ êµ¬í˜„
- [ ] ApplySkullVisuals() ë©”ì„œë“œ êµ¬í˜„
- [ ] ApplySkullAbilities() ë©”ì„œë“œ êµ¬í˜„
- [ ] AddSkull() ë©”ì„œë“œ êµ¬í˜„

---

## ğŸ’ Phase E-3: ë©”íƒ€ ì§„í–‰ ì‹œìŠ¤í…œ

**ì˜ˆìƒ ê¸°ê°„**: 1-2ì£¼
**í˜„ì¬ ìƒíƒœ**: ë¯¸ì°©ìˆ˜ (0%)
**ì„ í–‰ ìš”êµ¬ì‚¬í•­**: SaveSystem ì™„ë£Œ

---

### Step 1: ë©”íƒ€ í™”í ì‹œìŠ¤í…œ (3-5ì¼)

#### 1.1 MetaCurrency Enum

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/Core/Enums/MetaCurrency.cs`

**ì‘ì—… ë‚´ìš©**:
```csharp
namespace Core.Enums
{
    /// <summary>
    /// ë©”íƒ€ í™”í íƒ€ì…
    /// </summary>
    public enum MetaCurrency
    {
        Bone,   // ë¼ˆ (í”Œë ˆì´ ì¤‘ íšë“)
        Soul    // ì˜í˜¼ (ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ íšë“)
    }
}
```

---

#### 1.2 MetaCurrencySystem í´ë˜ìŠ¤

**íŒŒì¼ ìœ„ì¹˜**: `Assets/_Project/Scripts/Economy/MetaCurrencySystem.cs`

**í•µì‹¬ ë¡œì§**:
```csharp
using UnityEngine;
using Core.Enums;
using System;

namespace GASPT.Economy
{
    /// <summary>
    /// ë©”íƒ€ í™”í ì‹œìŠ¤í…œ
    /// ë¼ˆ, ì˜í˜¼ ê´€ë¦¬
    /// </summary>
    public class MetaCurrencySystem : MonoBehaviour
    {
        public static MetaCurrencySystem Instance { get; private set; }

        // í˜„ì¬ ë³´ìœ ëŸ‰
        private int boneCount = 0;
        private int soulCount = 0;

        // ì´ë²¤íŠ¸
        public event Action<MetaCurrency, int> OnCurrencyChanged;

        private void Awake()
        {
            if (Instance == null)
            {
                Instance = this;
                DontDestroyOnLoad(gameObject);
            }
            else
            {
                Destroy(gameObject);
            }
        }

        /// <summary>
        /// í™”í ì¶”ê°€
        /// </summary>
        public void AddCurrency(MetaCurrency type, int amount)
        {
            if (amount <= 0)
                return;

            switch (type)
            {
                case MetaCurrency.Bone:
                    boneCount += amount;
                    break;
                case MetaCurrency.Soul:
                    soulCount += amount;
                    break;
            }

            OnCurrencyChanged?.Invoke(type, GetCurrency(type));
            Debug.Log($"[MetaCurrency] {type} +{amount} (ì´: {GetCurrency(type)})");
        }

        /// <summary>
        /// í™”í ì‚¬ìš©
        /// </summary>
        public bool SpendCurrency(MetaCurrency type, int amount)
        {
            if (amount <= 0)
                return false;

            int current = GetCurrency(type);
            if (current < amount)
            {
                Debug.LogWarning($"[MetaCurrency] {type} ë¶€ì¡± (ë³´ìœ : {current}, í•„ìš”: {amount})");
                return false;
            }

            switch (type)
            {
                case MetaCurrency.Bone:
                    boneCount -= amount;
                    break;
                case MetaCurrency.Soul:
                    soulCount -= amount;
                    break;
            }

            OnCurrencyChanged?.Invoke(type, GetCurrency(type));
            Debug.Log($"[MetaCurrency] {type} -{amount} (ë‚¨ì€: {GetCurrency(type)})");
            return true;
        }

        /// <summary>
        /// í˜„ì¬ ë³´ìœ ëŸ‰ í™•ì¸
        /// </summary>
        public int GetCurrency(MetaCurrency type)
        {
            return type switch
            {
                MetaCurrency.Bone => boneCount,
                MetaCurrency.Soul => soulCount,
                _ => 0
            };
        }

        /// <summary>
        /// ì„¸ì´ë¸Œ/ë¡œë“œ
        /// </summary>
        public void SaveToData(SaveData saveData)
        {
            saveData.metaBoneCount = boneCount;
            saveData.metaSoulCount = soulCount;
        }

        public void LoadFromData(SaveData saveData)
        {
            boneCount = saveData.metaBoneCount;
            soulCount = saveData.metaSoulCount;
        }
    }
}
```

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
- [ ] MetaCurrencySystem.cs íŒŒì¼ ìƒì„±
- [ ] Singleton íŒ¨í„´ êµ¬í˜„
- [ ] AddCurrency() ë©”ì„œë“œ êµ¬í˜„
- [ ] SpendCurrency() ë©”ì„œë“œ êµ¬í˜„
- [ ] GetCurrency() ë©”ì„œë“œ êµ¬í˜„
- [ ] SaveToData(), LoadFromData() ë©”ì„œë“œ êµ¬í˜„
- [ ] SaveData.csì— metaBoneCount, metaSoulCount í•„ë“œ ì¶”ê°€

---

## âœ… ì‹œìŠ¤í…œë³„ êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Room Generator ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] RoomType Enum ìƒì„±
- [ ] RoomData í™•ì¥ (roomType, width, height ë“±)
- [ ] RoomGenerator í´ë˜ìŠ¤ ìƒì„±
- [ ] GenerateRoom() ë©”ì„œë“œ êµ¬í˜„
- [ ] ë°”ë‹¥/í”Œë«í¼/ì¥ì• ë¬¼ ìƒì„± ë¡œì§
- [ ] Unityì—ì„œ Tilemap ì„¤ì •
- [ ] í…ŒìŠ¤íŠ¸ ì”¬ì—ì„œ ë™ì‘ í™•ì¸

### Dungeon Generator ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] DungeonLayout, DungeonNode í´ë˜ìŠ¤ ìƒì„±
- [ ] DungeonGenerator í´ë˜ìŠ¤ ìƒì„±
- [ ] GenerateDungeon() ë©”ì„œë“œ êµ¬í˜„
- [ ] ì‹œì‘ ë°© â†’ ë³´ìŠ¤ ë°© ê²½ë¡œ ë³´ì¥
- [ ] ì„ íƒì  ê²½ë¡œ ìƒì„±
- [ ] í…ŒìŠ¤íŠ¸ ì”¬ì—ì„œ ë ˆì´ì•„ì›ƒ í™•ì¸

### Minimap ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] MinimapUI í´ë˜ìŠ¤ ìƒì„± (BaseUI ìƒì†)
- [ ] GenerateMinimap() ë©”ì„œë“œ êµ¬í˜„
- [ ] UpdateCurrentRoom() ë©”ì„œë“œ êµ¬í˜„
- [ ] ë°© ì•„ì´ì½˜ í”„ë¦¬íŒ¹ ìƒì„±
- [ ] Unityì—ì„œ UI ë°°ì¹˜
- [ ] í…ŒìŠ¤íŠ¸ ì”¬ì—ì„œ ë™ì‘ í™•ì¸

### Skull System ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] SkullData ScriptableObject ìƒì„±
- [ ] SkullManager í´ë˜ìŠ¤ ìƒì„±
- [ ] TransformToNextSkull() ë©”ì„œë“œ êµ¬í˜„
- [ ] EquipSkull() ë©”ì„œë“œ êµ¬í˜„
- [ ] ìŠ¤íƒ¯/ë¹„ì£¼ì–¼/ì–´ë¹Œë¦¬í‹° ì ìš© ë¡œì§
- [ ] Unityì—ì„œ SkullData ì—ì…‹ ìƒì„± (5ê°œ ì´ìƒ)
- [ ] í…ŒìŠ¤íŠ¸ ì”¬ì—ì„œ Qí‚¤ ë³€ì‹  í™•ì¸

### Meta Currency ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] MetaCurrency Enum ìƒì„±
- [ ] MetaCurrencySystem í´ë˜ìŠ¤ ìƒì„±
- [ ] AddCurrency(), SpendCurrency() ë©”ì„œë“œ êµ¬í˜„
- [ ] SaveDataì— ë©”íƒ€ í™”í í•„ë“œ ì¶”ê°€
- [ ] SaveSystem ì—°ë™
- [ ] í…ŒìŠ¤íŠ¸ ì”¬ì—ì„œ íšë“/ì‚¬ìš© í™•ì¸

---

## ğŸ› íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œ

### ë¬¸ì œ 1: Tilemapì´ í‘œì‹œë˜ì§€ ì•ŠìŒ

**ì¦ìƒ**:
- RoomGeneratorë¡œ ë°©ì„ ìƒì„±í–ˆì§€ë§Œ Tilemapì´ í™”ë©´ì— í‘œì‹œë˜ì§€ ì•ŠìŒ

**ì›ì¸**:
- Tilemap Rendererì˜ Sorting Layer ì„¤ì • ëˆ„ë½
- Tile ì°¸ì¡°ê°€ null
- Tilemap GameObjectê°€ ë¹„í™œì„±í™”

**í•´ê²° ë°©ë²•**:
1. Tilemap GameObject í™•ì¸:
   - Hierarchyì—ì„œ Tilemap ì„ íƒ
   - Inspectorì—ì„œ Tilemap Renderer í™•ì¸
   - Sorting Layer: "Ground" ë˜ëŠ” "Default"
   - Order in Layer: 0

2. Tile ì°¸ì¡° í™•ì¸:
   - RoomGenerator Inspectorì—ì„œ groundTile, platformTile ë“±ì´ í• ë‹¹ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
   - Tile ì—ì…‹ì´ Project í´ë”ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸

3. Tilemap í™œì„±í™” í™•ì¸:
   - Hierarchyì—ì„œ Tilemap GameObjectê°€ ì²´í¬ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸

---

### ë¬¸ì œ 2: ìŠ¤ì»¬ ë³€ì‹  ì‹œ ìŠ¤í”„ë¼ì´íŠ¸ê°€ ë°”ë€Œì§€ ì•ŠìŒ

**ì¦ìƒ**:
- Qí‚¤ë¥¼ ëˆŒëŸ¬ë„ ìŠ¤í”„ë¼ì´íŠ¸ê°€ ë³€ê²½ë˜ì§€ ì•ŠìŒ

**ì›ì¸**:
- SkullDataì˜ animatorController ë˜ëŠ” idleSpriteê°€ null
- PlayerRenderer ì°¸ì¡°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŒ
- Animator Componentê°€ ì—†ìŒ

**í•´ê²° ë°©ë²•**:
1. SkullData í™•ì¸:
   - Project í´ë”ì—ì„œ SkullData ì—ì…‹ ì„ íƒ
   - Inspectorì—ì„œ Animator Controller, Idle Sprite í• ë‹¹ í™•ì¸

2. PlayerRenderer í™•ì¸:
   - Player GameObjectì— SpriteRenderer Component ì¡´ì¬ í™•ì¸
   - SkullManagerì˜ Start()ì—ì„œ GetComponent<SpriteRenderer>() ì œëŒ€ë¡œ ë™ì‘í•˜ëŠ”ì§€ ë””ë²„ê·¸

3. Animator í™•ì¸:
   - Player GameObjectì— Animator Component ì¡´ì¬ í™•ì¸
   - Runtime Animator Controllerê°€ í• ë‹¹ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸

---

### ë¬¸ì œ 3: BaseUIë¥¼ ìƒì†í•œ UIê°€ í‘œì‹œë˜ì§€ ì•ŠìŒ

**ì¦ìƒ**:
- Show() ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ë„ UIê°€ í™”ë©´ì— ë‚˜íƒ€ë‚˜ì§€ ì•ŠìŒ

**ì›ì¸**:
- Panel GameObjectê°€ null
- Canvasê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŒ
- Panelì˜ ë¶€ëª¨ ê³„ì¸µ êµ¬ì¡°ê°€ ì˜ëª»ë¨

**í•´ê²° ë°©ë²•**:
1. Panel í™•ì¸:
   - Hierarchyì—ì„œ UI GameObject ì„ íƒ
   - "Panel"ì´ë¼ëŠ” ì´ë¦„ì˜ ìì‹ GameObjectê°€ ìˆëŠ”ì§€ í™•ì¸
   - Inspectorì—ì„œ panel í•„ë“œê°€ í• ë‹¹ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸

2. Canvas í™•ì¸:
   - Hierarchyì—ì„œ "=== UI CANVAS ===" GameObject í™•ì¸
   - Canvas Componentê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸

3. InitializePanel() ë””ë²„ê·¸:
   - BaseUIì˜ InitializePanel()ì— Debug.Log ì¶”ê°€
   - Panelì´ ì œëŒ€ë¡œ ì°¾ì•„ì§€ëŠ”ì§€ í™•ì¸

---

## ğŸ“š ì½”ë“œ ìŠ¤ë‹ˆí« ë¼ì´ë¸ŒëŸ¬ë¦¬

### Singleton íŒ¨í„´ (DontDestroyOnLoad)

```csharp
public class ExampleManager : MonoBehaviour
{
    public static ExampleManager Instance { get; private set; }

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
```

---

### ScriptableObject ìƒì„± í…œí”Œë¦¿

```csharp
using UnityEngine;

[CreateAssetMenu(fileName = "NewData", menuName = "GASPT/Data/New Data")]
public class ExampleData : ScriptableObject
{
    [Header("Basic Info")]
    public string dataName;

    [TextArea(3, 5)]
    public string description;

    [Header("Settings")]
    [Range(0, 100)]
    public int someValue = 50;
}
```

---

### BaseUI ìƒì† í…œí”Œë¦¿

```csharp
using UnityEngine;
using UnityEngine.UI;

namespace GASPT.UI
{
    public class ExampleUI : BaseUI
    {
        [Header("UI Elements")]
        [SerializeField] private Text titleText;
        [SerializeField] private Button confirmButton;

        protected override void Awake()
        {
            base.Awake(); // Panel ìë™ ì°¾ê¸°

            // ë²„íŠ¼ ì´ë²¤íŠ¸ ì—°ê²°
            if (confirmButton != null)
            {
                confirmButton.onClick.AddListener(OnConfirmClicked);
            }
        }

        protected override void Initialize()
        {
            // ì¶”ê°€ ì´ˆê¸°í™” ë¡œì§
        }

        private void OnConfirmClicked()
        {
            Hide();
        }
    }
}
```

---

### async Awaitable íŒ¨í„´

```csharp
using UnityEngine;

public class ExampleAsync : MonoBehaviour
{
    private async Awaitable LoadDataAsync()
    {
        Debug.Log("ë¡œë”© ì‹œì‘");

        // 1ì´ˆ ëŒ€ê¸°
        await Awaitable.WaitForSecondsAsync(1f);

        Debug.Log("ë¡œë”© ì™„ë£Œ");
    }

    private void Start()
    {
        LoadDataAsync().Forget(); // Fire and forget
    }
}
```

---

### Event System íŒ¨í„´

```csharp
using System;

public class ExampleEventSystem
{
    // ì´ë²¤íŠ¸ ì •ì˜
    public event Action<int> OnValueChanged;

    private int value;

    // ê°’ ë³€ê²½ ì‹œ ì´ë²¤íŠ¸ ë°œìƒ
    public void SetValue(int newValue)
    {
        value = newValue;
        OnValueChanged?.Invoke(value);
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
public class ExampleListener : MonoBehaviour
{
    private ExampleEventSystem system;

    private void Start()
    {
        system = new ExampleEventSystem();

        // ì´ë²¤íŠ¸ êµ¬ë…
        system.OnValueChanged += OnValueChangedHandler;
    }

    private void OnDestroy()
    {
        // ì´ë²¤íŠ¸ êµ¬ë… í•´ì œ
        if (system != null)
        {
            system.OnValueChanged -= OnValueChangedHandler;
        }
    }

    private void OnValueChangedHandler(int newValue)
    {
        Debug.Log($"ê°’ ë³€ê²½: {newValue}");
    }
}
```

---

### Object Pooling íŒ¨í„´

```csharp
using UnityEngine;
using GASPT.ObjectPool;

public class ExamplePooling : MonoBehaviour
{
    [SerializeField] private GameObject prefab;
    private ObjectPool<GameObject> pool;

    private void Start()
    {
        // í’€ ì´ˆê¸°í™”
        pool = new ObjectPool<GameObject>(
            createFunc: () => Instantiate(prefab),
            onGet: obj => obj.SetActive(true),
            onRelease: obj => obj.SetActive(false),
            onDestroy: obj => Destroy(obj),
            defaultCapacity: 10,
            maxSize: 100
        );
    }

    private void SpawnObject()
    {
        // í’€ì—ì„œ ê°€ì ¸ì˜¤ê¸°
        GameObject obj = pool.Get();

        // 5ì´ˆ í›„ í’€ì— ë°˜í™˜
        Invoke(nameof(ReturnObject), 5f);
    }

    private void ReturnObject(GameObject obj)
    {
        pool.Release(obj);
    }
}
```

---

## ğŸ”— ê´€ë ¨ ë¬¸ì„œ

- [PROJECT_MASTER_ROADMAP.md](PROJECT_MASTER_ROADMAP.md) - ì „ì²´ ë¡œë“œë§µ
- [WORK_HISTORY.md](WORK_HISTORY.md) - ì™„ë£Œëœ ì‘ì—… ë‚´ì—­
- [CodingGuidelines.md](CodingGuidelines.md) - ì½”ë”© ê·œì¹™
- [UI_SYSTEM_DESIGN.md](../guides/UI_SYSTEM_DESIGN.md) - UI ì‹œìŠ¤í…œ ì„¤ê³„

---

**ìµœì¢… ì—…ë°ì´íŠ¸**: 2025-11-19
**ì‘ì„±ì**: GASPT ê°œë°œíŒ€

---

*ì´ ê°€ì´ë“œëŠ” ì„œë²„ ì˜¤ë¥˜ ì‹œ ìˆ˜ë™ìœ¼ë¡œ ì‘ì—…ì„ ì§„í–‰í•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.*
*ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ë”°ë¼ ë‹¨ê³„ë³„ë¡œ êµ¬í˜„í•˜ê³ , ì½”ë“œ ìŠ¤ë‹ˆí«ì„ ì°¸ì¡°í•˜ì„¸ìš”.*
